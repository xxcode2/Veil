// reveal_result.arcis
// Decrypts votes, selects random saboteur, computes result
// THIS IS THE CORE MPC LOGIC - runs inside secure enclave

use arcium::prelude::*;

#[computation_output]
pub struct RevealOutput {
    pub saboteur_index: Plaintext<u8>,
    pub saboteur_voted_safe: Plaintext<bool>,
    pub community_voted_safe: Plaintext<bool>,
    pub community_won: Plaintext<bool>,
    pub player_results: Vec<Plaintext<bool>>, // Each player: did they win?
}

#[computation]
pub fn reveal_result(
    game_nonce: Plaintext<u128>,
    num_players: Plaintext<u8>,
    vote_state: EncryptedAccountData,
) -> RevealOutput {
    // Read and decrypt all votes
    let encrypted_votes = vote_state.read_array::<u8, 8>();
    let mut votes: [u8; 8] = [0; 8];
    
    for i in 0..(num_players.value() as usize) {
        votes[i] = encrypted_votes[i].decrypt(game_nonce.value());
    }
    
    // ==== RANDOM SABOTEUR SELECTION (INSIDE MPC) ====
    // Server never knows this until reveal
    let entropy = secure_random_bytes(32);
    let saboteur_index = (entropy[0] as usize) % (num_players.value() as usize);
    
    // Get saboteur's vote
    let saboteur_voted_safe = votes[saboteur_index] == 1;
    
    // ==== COUNT COMMUNITY VOTES (EXCLUDING SABOTEUR) ====
    let mut safe_count = 0u32;
    let mut unsafe_count = 0u32;
    
    for i in 0..(num_players.value() as usize) {
        if i == saboteur_index {
            continue; // Skip saboteur
        }
        
        if votes[i] == 1 {
            safe_count += 1;
        } else if votes[i] == 0 {
            unsafe_count += 1;
        }
        // votes[i] == 255 means not voted (shouldn't happen)
    }
    
    // Determine majority
    let community_voted_safe = safe_count > unsafe_count;
    
    // ==== WINNING LOGIC ====
    // Community wins if they voted OPPOSITE of saboteur
    let community_won = community_voted_safe != saboteur_voted_safe;
    
    // ==== INDIVIDUAL PLAYER RESULTS ====
    let mut player_results = Vec::new();
    
    for i in 0..(num_players.value() as usize) {
        let player_voted_safe = votes[i] == 1;
        
        let player_won = if i == saboteur_index {
            // Saboteur wins if community voted same as them (community loses)
            !community_won
        } else {
            // Regular player wins if they voted with majority
            player_voted_safe == community_voted_safe
        };
        
        player_results.push(Plaintext::new(player_won));
    }
    
    RevealOutput {
        saboteur_index: Plaintext::new(saboteur_index as u8),
        saboteur_voted_safe: Plaintext::new(saboteur_voted_safe),
        community_voted_safe: Plaintext::new(community_voted_safe),
        community_won: Plaintext::new(community_won),
        player_results,
    }
}
